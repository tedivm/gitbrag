from logging import getLogger

from github import Auth, Github

from gitbrag.conf.github import GitHubAuthType, GitHubSettings

from .oauth import GitHubOAuthFlow

logger = getLogger(__name__)


class GitHubClient:
    """Wrapper for PyGithub client with authentication."""

    def __init__(self, settings: GitHubSettings | None = None, token_override: str | None = None) -> None:
        """Initialize with settings.

        Args:
            settings: GitHub settings (defaults to global settings)
            token_override: Optional PAT token to override settings
        """
        if settings is None:
            from gitbrag.settings import settings as global_settings

            settings = global_settings

        self.settings = settings
        self.token_override = token_override
        self._client: Github | None = None

    async def get_authenticated_client(self) -> Github:
        """Return authenticated PyGithub client.

        For PAT: Use token directly.
        For GitHub App: Complete OAuth flow if needed, use user access token.

        Returns:
            Authenticated PyGithub client

        Raises:
            ValueError: If authentication fails or configuration is invalid
        """
        if self._client is not None:
            return self._client

        # Use token override if provided
        if self.token_override:
            logger.info("Using token override for authentication")
            auth = Auth.Token(self.token_override)
            self._client = Github(auth=auth)
            return self._client

        # PAT authentication
        if self.settings.github_auth_type == GitHubAuthType.PAT:
            if not self.settings.github_token:
                raise ValueError("GitHub token not configured. Set GITHUB_TOKEN environment variable.")

            logger.info("Using Personal Access Token for authentication")
            auth = Auth.Token(self.settings.github_token.get_secret_value())
            self._client = Github(auth=auth)
            return self._client

        # GitHub App OAuth authentication
        elif self.settings.github_auth_type == GitHubAuthType.GITHUB_APP:
            if not self.settings.github_app_client_id or not self.settings.github_app_client_secret:
                raise ValueError("GitHub App credentials not configured. Set GITHUB_APP_CLIENT_ID and GITHUB_APP_CLIENT_SECRET.")

            logger.info("Starting GitHub App OAuth flow")
            oauth_flow = GitHubOAuthFlow(
                client_id=self.settings.github_app_client_id,
                client_secret=self.settings.github_app_client_secret,
                callback_port=self.settings.github_oauth_callback_port,
            )

            await oauth_flow.initiate_flow()
            access_token = await oauth_flow.complete_flow()

            logger.info("GitHub App OAuth authentication successful")
            auth = Auth.Token(access_token)
            self._client = Github(auth=auth)
            return self._client

        else:
            raise ValueError(f"Unsupported authentication type: {self.settings.github_auth_type}")

    def get_rate_limit(self) -> dict[str, int]:
        """Get current rate limit status.

        Returns:
            Dictionary with rate limit information (core, search, graphql)

        Raises:
            ValueError: If client not authenticated yet
        """
        if not self._client:
            raise ValueError("Client not authenticated. Call get_authenticated_client() first.")

        rate_limit = self._client.get_rate_limit()

        return {
            "core_limit": rate_limit.core.limit,  # type: ignore[attr-defined]
            "core_remaining": rate_limit.core.remaining,  # type: ignore[attr-defined]
            "search_limit": rate_limit.search.limit,  # type: ignore[attr-defined]
            "search_remaining": rate_limit.search.remaining,  # type: ignore[attr-defined]
            "graphql_limit": rate_limit.graphql.limit,  # type: ignore[attr-defined]
            "graphql_remaining": rate_limit.graphql.remaining,  # type: ignore[attr-defined]
        }
